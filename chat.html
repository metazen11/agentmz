<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agentic v2 - Coding Agent</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%230F172A'/><path d='M25 50L45 70L80 30' stroke='%2338BDF8' stroke-width='12' fill='none' stroke-linecap='round' stroke-linejoin='round'/><circle cx='80' cy='30' r='8' fill='%23FFF'/></svg>">
<link rel="stylesheet" href="/static/css/base.css">
<link rel="stylesheet" href="/static/css/components.css">
<link rel="stylesheet" href="/static/css/sidebar.css">
<link rel="stylesheet" href="/static/css/chat.css">
<link rel="stylesheet" href="/static/css/logs.css">
<link rel="stylesheet" href="/static/css/forms.css">
</head>
<body>
<div class="container">
  <h1>Agentic v2</h1>
  <p class="subtitle">Coding agent powered by Ollama + Aider</p>

  <div class="main-layout">
    <!-- Sidebar: Projects and Tasks -->
    <div class="sidebar">
      <div class="sidebar-section-header">
        <h3>Projects</h3>
        <button class="btn-small" onclick="showNewProjectModal()">+ New Project</button>
      </div>
      <ul class="project-list" id="project-list">
        <li>Loading...</li>
      </ul>

      <div class="sidebar-section-header spaced">
        <h3>Tasks</h3>
        <button class="btn-small" onclick="showNewTaskModal()">+ New Task</button>
      </div>
      <ul class="task-list" id="task-list">
        <li style="color: #666;">Select a project</li>
      </ul>

      <div class="file-tree" id="file-tree">
        <div class="file-tree-header">
          <h3>Files</h3>
          <button class="btn-small" onclick="showGitModal()">Git</button>
        </div>
        <div id="file-tree-content">
          <span style="color: #666;">Select a project</span>
        </div>
      </div>
    </div>

    <!-- Main Chat Panel -->
    <div class="chat-panel">
    <div class="status-bar">
      <div id="status" class="status">Checking connection...</div>
      <button id="heal-btn" class="secondary" onclick="runFullHealthCheck(true)">Heal</button>
      <div class="selector model-selector">
        <label for="model-select">Model</label>
        <select id="model-select" disabled>
          <option value="">Loading...</option>
        </select>
        <button id="model-apply" class="secondary" onclick="applyModelSelection()" disabled>Set</button>
      </div>
      <button class="secondary" onclick="showSettingsModal()">Settings</button>
    </div>

      <div id="messages"></div>

      <div id="input-form">
        <textarea id="prompt" placeholder="Ask the agent to edit code..."></textarea>
        <button id="send">Send</button>
      </div>
      <div id="image-dropzone" class="image-dropzone">
        Drag & drop images here, or <button class="btn-small" onclick="openImagePicker()">browse</button>
        <input id="image-input" type="file" accept="image/*" multiple style="display:none;">
      </div>
      <div class="selector vision-selector">
        <label for="vision-model-select">Vision</label>
        <select id="vision-model-select" disabled>
          <option value="">Loading...</option>
        </select>
      </div>
      <div id="image-list" class="image-list"></div>

    </div>
  </div>

  <!-- Logs Panel -->
  <div class="logs-panel">
    <div class="logs-header" onclick="toggleLogs()">
      <div style="display: flex; align-items: center;">
        <h3>Container Logs</h3>
        <span id="logs-connection" class="connection-status disconnected">disconnected</span>
      </div>
      <div class="logs-tabs" onclick="event.stopPropagation()">
        <button id="tab-ollama_http" class="active" onclick="switchLogTab('ollama_http')">Ollama HTTP</button>
        <button id="tab-ollama" onclick="switchLogTab('ollama')">Ollama</button>
        <button id="tab-aider" onclick="switchLogTab('aider')">Aider</button>
        <button id="tab-main" onclick="switchLogTab('main')">Main API</button>
      </div>
    </div>
    <div id="logs-content" class="logs-content">
      <div id="log-pane-ollama_http" class="log-pane"></div>
      <div id="log-pane-ollama" class="log-pane" style="display:none;"></div>
      <div id="log-pane-aider" class="log-pane" style="display:none;"></div>
      <div id="log-pane-main" class="log-pane" style="display:none;"></div>
    </div>
  </div>
</div>

<!-- New Project Modal -->
<div id="new-project-modal" class="modal" style="display:none;">
  <div class="modal-content">
    <h3>New Project</h3>
    <label style="font-size:12px; color:#aaa;">Name</label>
    <input type="text" id="new-project-name" placeholder="Project name">
    <label style="font-size:12px; color:#aaa; margin-top:8px;">Workspace (folder name in /workspaces/)</label>
    <input type="text" id="new-project-workspace" placeholder="e.g. poc, my_app">
    <div class="modal-actions">
      <button onclick="createProject()">Create</button>
      <button class="secondary" onclick="hideModals()">Cancel</button>
    </div>
  </div>
</div>

<!-- Edit Project Modal -->
<div id="edit-project-modal" class="modal" style="display:none;">
  <div class="modal-content">
    <h3>Edit Project</h3>
    <label style="font-size:12px; color:#aaa;">Name</label>
    <input type="text" id="edit-project-name" placeholder="Project name">
    <label style="font-size:12px; color:#aaa; margin-top:8px;">Workspace (folder name only, e.g. poc)</label>
    <input type="text" id="edit-project-workspace" placeholder="e.g. poc, beatbridge_app">
    <label style="font-size:12px; color:#aaa; margin-top:8px;">Environment</label>
    <input type="text" id="edit-project-environment" placeholder="e.g. local">
    <div class="modal-actions">
      <button onclick="updateProject()">Save</button>
      <button class="secondary" onclick="hideModals()">Cancel</button>
    </div>
  </div>
</div>

<!-- New Task Modal -->
<div id="new-task-modal" class="modal" style="display:none;">
  <div class="modal-content">
    <h3>New Task</h3>
    <input type="text" id="new-task-title" placeholder="Task title">
    <textarea id="new-task-desc" placeholder="Description (optional)"></textarea>
    <label style="font-size:12px; color:#aaa; margin-top:8px;">Parent Task (optional)</label>
    <select id="new-task-parent-id">
      <option value="">No parent</option>
    </select>
    <label style="font-size:12px; color:#aaa; margin-top:8px;">Stage</label>
    <select id="new-task-stage">
      <option value="dev">dev</option>
      <option value="qa">qa</option>
      <option value="review">review</option>
      <option value="complete">complete</option>
    </select>
    <label style="font-size:12px; color:#aaa; margin-top:8px;">Status</label>
    <select id="new-task-status">
      <option value="backlog">backlog</option>
      <option value="in_progress">in_progress</option>
      <option value="done">done</option>
      <option value="failed">failed</option>
    </select>
    <div class="modal-actions">
      <button onclick="createTask()">Create</button>
      <button class="secondary" onclick="hideModals()">Cancel</button>
    </div>
  </div>
</div>

<!-- Edit Task Modal -->
<div id="edit-task-modal" class="modal" style="display:none;">
  <div class="modal-content task-modal-content">
    <h3>Edit Task</h3>
    <input type="text" id="edit-task-title" placeholder="Task title">
    <textarea id="edit-task-desc" placeholder="Description (optional)"></textarea>
    <div id="edit-task-parent-row" class="task-parent-row" style="display:none;">
      Parent: <a href="#" id="edit-task-parent-link"></a>
    </div>
    <button class="btn-small" onclick="createSubtask(getEditingTaskId())">+ Add Subtask</button>
    <label style="font-size:12px; color:#aaa; margin-top:8px;">Stage</label>
    <select id="edit-task-stage">
      <option value="dev">dev</option>
      <option value="qa">qa</option>
      <option value="review">review</option>
      <option value="complete">complete</option>
    </select>
    <label style="font-size:12px; color:#aaa; margin-top:8px;">Status</label>
    <select id="edit-task-status">
      <option value="backlog">backlog</option>
      <option value="in_progress">in_progress</option>
      <option value="done">done</option>
      <option value="failed">failed</option>
    </select>

    <div class="details-panel">
      <div class="details-title">Acceptance Criteria</div>
      <div id="task-criteria-list" class="criteria-list">No criteria</div>
      <input type="text" id="criteria-desc" placeholder="Add acceptance criteria">
      <input type="text" id="criteria-author" placeholder="Author (optional)">
      <div class="comment-actions">
        <button onclick="addAcceptanceCriteria()">Add Criteria</button>
      </div>
    </div>

    <div class="details-panel">
      <div class="details-title">Comments</div>
      <div id="task-comments-list" class="comment-list">No comments</div>
      <input type="text" id="comment-author" placeholder="Author (optional)">
      <textarea id="comment-body" placeholder="Add a comment"></textarea>
      <input type="hidden" id="comment-id">
      <div class="comment-actions">
        <button onclick="saveTaskComment()">Save Comment</button>
        <button class="secondary" onclick="resetCommentForm()">Cancel</button>
      </div>
    </div>

    <div class="details-panel">
      <div class="details-title">Attachments</div>
      <div id="task-attachments-list" class="attachment-list">No attachments</div>
      <input type="file" id="attachment-file">
      <input type="text" id="attachment-uploaded-by" placeholder="Uploaded by (optional)">
      <select id="attachment-comment-id">
        <option value="">Attach to task</option>
      </select>
      <div class="comment-actions">
        <button onclick="uploadTaskAttachment()">Upload</button>
      </div>
    </div>

    <div class="modal-actions">
      <button onclick="updateTask()">Save</button>
      <button class="delete" onclick="deleteTask(getEditingTaskId())">Delete</button>
      <button class="secondary" onclick="hideModals()">Cancel</button>
    </div>
  </div>
</div>

<!-- Git Modal -->
<div id="git-modal" class="modal" style="display:none;">
  <div class="modal-content">
    <h3>Git</h3>
    <div class="git-modal-grid">
      <div class="git-meta" id="git-current-branch">Current branch: -</div>
      <div class="git-meta" id="git-user-config">User: -</div>
      <div class="git-row">
        <button onclick="initGitRepo()">Init Repo</button>
      </div>
      <div class="git-row">
        <input id="git-user-name" type="text" placeholder="user.name">
        <input id="git-user-email" type="text" placeholder="user.email">
        <button onclick="saveGitUser()">Save User</button>
      </div>
      <div class="git-row">
        <select id="git-branch-select" disabled>
          <option value="">No repo</option>
        </select>
        <button onclick="checkoutBranch()">Checkout</button>
      </div>
      <div class="git-row">
        <input id="git-branch-input" type="text" placeholder="new branch name">
        <button onclick="createBranch()">Create</button>
      </div>
      <div class="git-row">
        <select id="git-remote-select" disabled>
          <option value="">No remotes</option>
        </select>
        <button onclick="pullBranch()">Pull</button>
        <button onclick="pushBranch()">Push</button>
      </div>
      <div class="git-row">
        <input id="git-remote-name" type="text" placeholder="remote name">
        <input id="git-remote-url" type="text" placeholder="remote url">
        <button onclick="addRemote()">Add Remote</button>
      </div>
      <div class="git-remote-list" id="git-remote-list">No remotes</div>
      <div class="git-log" id="git-log">Git output will appear here...</div>
      <div class="modal-actions">
        <button class="secondary" onclick="hideGitModal()">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div id="settings-modal" class="modal" style="display:none;">
  <div class="modal-content">
    <h3>Settings (.env)</h3>
    <div class="settings-modal-grid">
      <input id="settings-filter" type="text" placeholder="Filter settings...">
      <div class="settings-list" id="settings-list">Loading...</div>
      <div class="git-row">
        <label><input type="checkbox" id="restart-main" checked> Restart main</label>
        <label><input type="checkbox" id="restart-aider" checked> Restart aider</label>
        <label><input type="checkbox" id="restart-ollama"> Restart ollama</label>
        <label><input type="checkbox" id="restart-db"> Restart db</label>
      </div>
      <div class="modal-actions">
        <button onclick="applySettings()">Apply</button>
        <button class="secondary" onclick="hideSettingsModal()">Close</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
// ============================================================================
// Imports from extracted modules
// ============================================================================
import { MAIN_API, AIDER_API, HEALTH_CHECK_INTERVAL_MS, getMainApiBase, initDom } from '/static/js/config.js';
import { COOKIE_KEYS, setCookie, getCookie, deleteCookie, getWorkspaceName, getDisplayWorkspaceName } from '/static/js/cookies.js';
import { renderMarkdown } from '/static/js/markdown.js';
import { getResizedImageBase64 } from '/static/js/images.js';
import { highlightJson, getToolCallSummary, renderToolCalls } from '/static/js/tools.js';
import { state, setProjects, setTasks, setSelectedProject, setSelectedTask, setAvailableModels, setIsModelSwitching, setReferencedFiles, setAttachedImages, setEnvEntries, setEditingProjectId, setEditingTaskId, setCurrentLogTab, setVisionModel } from '/static/js/state.js';

// ============================================================================
// DOM elements (local refs for performance - also available via dom.*)
// ============================================================================
const messagesEl = document.getElementById('messages');
const promptEl = document.getElementById('prompt');
const sendBtn = document.getElementById('send');
const statusEl = document.getElementById('status');
const modelSelectEl = document.getElementById('model-select');
const modelApplyBtn = document.getElementById('model-apply');
const visionModelSelectEl = document.getElementById('vision-model-select');
const projectListEl = document.getElementById('project-list');
const taskListEl = document.getElementById('task-list');
const fileTreeEl = document.getElementById('file-tree');
const gitBranchSelectEl = document.getElementById('git-branch-select');
const gitBranchInputEl = document.getElementById('git-branch-input');
const gitRemoteSelectEl = document.getElementById('git-remote-select');
const gitRemoteNameEl = document.getElementById('git-remote-name');
const gitRemoteUrlEl = document.getElementById('git-remote-url');
const gitCurrentBranchEl = document.getElementById('git-current-branch');
const gitUserConfigEl = document.getElementById('git-user-config');
const gitRemoteListEl = document.getElementById('git-remote-list');
const gitUserNameEl = document.getElementById('git-user-name');
const gitUserEmailEl = document.getElementById('git-user-email');
const gitLogEl = document.getElementById('git-log');
const imageDropzoneEl = document.getElementById('image-dropzone');
const imageInputEl = document.getElementById('image-input');
const imageListEl = document.getElementById('image-list');
const settingsListEl = document.getElementById('settings-list');
const settingsFilterEl = document.getElementById('settings-filter');
const restartMainEl = document.getElementById('restart-main');
const restartAiderEl = document.getElementById('restart-aider');
const restartOllamaEl = document.getElementById('restart-ollama');
const restartDbEl = document.getElementById('restart-db');
const taskCommentsListEl = document.getElementById('task-comments-list');
const commentAuthorEl = document.getElementById('comment-author');
const commentBodyEl = document.getElementById('comment-body');
const commentIdEl = document.getElementById('comment-id');
const taskAttachmentsListEl = document.getElementById('task-attachments-list');
const attachmentFileEl = document.getElementById('attachment-file');
const attachmentUploadedByEl = document.getElementById('attachment-uploaded-by');
const attachmentCommentIdEl = document.getElementById('attachment-comment-id');
const newTaskParentSelectEl = document.getElementById('new-task-parent-id');
const editTaskParentRowEl = document.getElementById('edit-task-parent-row');
const editTaskParentLinkEl = document.getElementById('edit-task-parent-link');
const criteriaListEl = document.getElementById('task-criteria-list');
const criteriaDescEl = document.getElementById('criteria-desc');
const criteriaAuthorEl = document.getElementById('criteria-author');

// ============================================================================
// Local state aliases (getter shortcuts to state module)
// ============================================================================
const getProjects = () => state.projects;
const getTasks = () => state.tasks;
const getSelectedProject = () => state.selectedProject;
const getSelectedTask = () => state.selectedTask;
const getAvailableModels = () => state.availableModels;
const getIsModelSwitching = () => state.isModelSwitching;
const getReferencedFiles = () => state.referencedFiles;
const getAttachedImages = () => state.attachedImages;
const getEnvEntries = () => state.envEntries;
const getEditingProjectId = () => state.editingProjectId;
const getEditingTaskId = () => state.editingTaskId;
const getCurrentLogTab = () => state.currentLogTab;

let taskComments = [];
let taskAttachments = [];
let editingCommentId = null;
let visionImageMaxSize = 640;
let visionModelRegex = null;
let pendingParentTaskId = null;
let taskCriteria = [];

function formatDate(value) {
  if (!value) return '-';
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) return value;
  return parsed.toLocaleString();
}

function escapeHtml(value) {
  return String(value ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function renderTooltip(rows) {
  const items = rows.filter(Boolean).map(row => `
    <div class="tooltip-row">
      <span class="tooltip-label">${escapeHtml(row.label)}</span>
      <span class="tooltip-value">${escapeHtml(row.value)}</span>
    </div>
  `).join('');
  return `<div class="tooltip">${items}</div>`;
}

function flattenTasks(taskList, depth = 0, out = []) {
  taskList.forEach(task => {
    out.push({ id: task.id, title: task.title || `Task ${task.id}`, depth });
    if (Array.isArray(task.children) && task.children.length > 0) {
      flattenTasks(task.children, depth + 1, out);
    }
  });
  return out;
}

function populateParentTaskOptions(selectedId = null) {
  if (!newTaskParentSelectEl) return;
  const tasks = flattenTasks(state.tasks);
  const options = ['<option value="">No parent</option>'];
  tasks.forEach(task => {
    const prefix = task.depth > 0 ? `${'-'.repeat(task.depth * 2)} ` : '';
    options.push(`<option value="${task.id}">${prefix}#${task.id} ${escapeHtml(task.title)}</option>`);
  });
  newTaskParentSelectEl.innerHTML = options.join('');
  if (selectedId) {
    newTaskParentSelectEl.value = String(selectedId);
  }
}

function isLikelyVisionModel(model) {
  if (!model) return false;
  if (visionModelRegex) {
    try {
      const regex = new RegExp(visionModelRegex, 'i');
      return regex.test(model);
    } catch (err) {
      return false;
    }
  }
  return /(^|[\\/:_-])(vl|vision|llava|mllama|moondream|minicpm-v|qwen2\\.5vl|qwen2-vl|qwen-vl|clip)/i.test(model);
}

async function restoreSelectionsFromCookies() {
  // Restore project selection
  const savedProjectId = getCookie(COOKIE_KEYS.PROJECT_ID);
  let projectRestored = false;

  if (savedProjectId) {
    const projectId = parseInt(savedProjectId, 10);
    const projectExists = state.projects.some(p => p.id === projectId);
    if (projectExists) {
      await selectProject(projectId);
      projectRestored = true;
    } else {
      // Project no longer exists, clear the cookie
      deleteCookie(COOKIE_KEYS.PROJECT_ID);
    }
  }

  // Fall back to first project if no valid cookie
  if (!projectRestored && state.projects.length > 0) {
    await selectProject(state.projects[0].id);
  }

  // NOTE: Agent model selection is NOT restored from cookie.
  // The dropdown is set by loadModels() based on the actual API config (agent_model).
  // This ensures the UI always reflects what Aider/Ollama are actually configured to use.
  // The cookie is only used to track successful model switches for debugging.
  // Vision model selection is restored in loadModels() based on config and cookie.
}

// Initialize
async function init() {
  console.log('init() called');
  initDom();
  await runFullHealthCheck(true);
  await checkHealth();
  await loadModels();
  await loadProjects();
  setupImageDropzone();
  // Restore project and model selections from cookies (or fall back to first project)
  await restoreSelectionsFromCookies();
  // Start log streaming for default tab only
  switchLogTab(state.currentLogTab);
  console.log('init() complete');
  setInterval(() => runFullHealthCheck(false), HEALTH_CHECK_INTERVAL_MS);
}

async function checkHealth() {
  const healBtn = document.getElementById('heal-btn');
  try {
    const [mainRes, aiderRes] = await Promise.all([
      fetch(`${getMainApiBase()}/projects`).catch(() => null),
      fetch(`${AIDER_API}/health`).catch(() => null)
    ]);

    const mainOk = mainRes && mainRes.ok;
    const aiderOk = aiderRes && aiderRes.ok;

    if (mainOk && aiderOk) {
      const aiderData = await aiderRes.json();
      const modelLabel = aiderData.agent_model || aiderData.aider_model || 'ready';
      statusEl.textContent = state.isModelSwitching
        ? `Switching model...`
        : `Connected - Model: ${modelLabel}`;
      statusEl.className = 'status connected';
      healBtn.classList.remove('show');  // Hide heal button when connected
    } else {
      const missing = [];
      if (!mainOk) missing.push('main-api:8002');
      if (!aiderOk) missing.push('aider-api:8001');
      statusEl.textContent = `Missing: ${missing.join(', ')}`;
      statusEl.className = 'status error';
      healBtn.classList.add('show');  // Show heal button when degraded
    }
  } catch (err) {
    statusEl.textContent = 'Connection error';
    statusEl.className = 'status error';
    healBtn.classList.add('show');  // Show heal button on error
  }
}

function toAiderModel(model) {
  if (!model) return '';
  if (model.startsWith('ollama_chat/') || model.startsWith('ollama/')) {
    return model;
  }
  return `ollama_chat/${model}`;
}

async function loadModels() {
  modelSelectEl.disabled = true;
  modelApplyBtn.disabled = true;
  modelSelectEl.innerHTML = '<option value="">Loading...</option>';
  if (visionModelSelectEl) {
    visionModelSelectEl.disabled = true;
    visionModelSelectEl.innerHTML = '<option value="">Loading...</option>';
  }

  try {
    const [modelsRes, configRes] = await Promise.all([
      fetch(`${AIDER_API}/api/models`).catch(() => null),
      fetch(`${AIDER_API}/api/config`).catch(() => null)
    ]);

    let models = [];
    if (modelsRes && modelsRes.ok) {
      const modelsData = await modelsRes.json();
      if (modelsData.success && Array.isArray(modelsData.models)) {
        models = modelsData.models;
      }
    }

    let currentAgentModel = '';
    let currentVisionModel = '';
    let visionAllowlist = [];
    if (configRes && configRes.ok) {
      const configData = await configRes.json();
      currentAgentModel = configData.config?.agent_model || '';
      currentVisionModel = configData.config?.vision_model || '';
      visionAllowlist = Array.isArray(configData.config?.vision_models)
        ? configData.config.vision_models
        : [];
      visionImageMaxSize = parseInt(configData.config?.vision_image_max_size, 10) || visionImageMaxSize;
      visionModelRegex = configData.config?.vision_model_regex || visionModelRegex;
    }

    if (!models.length) {
      modelSelectEl.innerHTML = '<option value="">No models found</option>';
      if (visionModelSelectEl) {
        visionModelSelectEl.innerHTML = '<option value="">No models found</option>';
        visionModelSelectEl.disabled = true;
        setVisionModel('');
      }
      return;
    }

    if (currentAgentModel && models.includes(currentAgentModel)) {
      models = [currentAgentModel, ...models.filter(model => model !== currentAgentModel)];
    }
    setAvailableModels(models);
    modelSelectEl.innerHTML = models.map(model => (
      `<option value="${model}">${model}</option>`
    )).join('');
    modelSelectEl.disabled = false;
    modelApplyBtn.disabled = false;

    if (currentAgentModel && models.includes(currentAgentModel)) {
      modelSelectEl.value = currentAgentModel;
    }

    if (visionModelSelectEl) {
      const visionModels = visionAllowlist.length
        ? models.filter(model => visionAllowlist.includes(model))
        : models.filter(model => isLikelyVisionModel(model));

      if (!visionModels.length) {
        visionModelSelectEl.innerHTML = '<option value="">No vision models found</option>';
        visionModelSelectEl.disabled = true;
        setVisionModel('');
        return;
      }

      visionModelSelectEl.innerHTML = visionModels.map(model => (
        `<option value="${model}">${model}</option>`
      )).join('');
      visionModelSelectEl.disabled = false;

      const savedVisionModel = getCookie(COOKIE_KEYS.VISION_MODEL);
      const selectedVisionModel = (
        (savedVisionModel && visionModels.includes(savedVisionModel) && savedVisionModel)
        || (currentVisionModel && visionModels.includes(currentVisionModel) && currentVisionModel)
        || visionModels[0]
      );
      visionModelSelectEl.value = selectedVisionModel;
      setVisionModel(selectedVisionModel);
    }
  } catch (err) {
    console.warn('Failed to load models:', err.message);
    modelSelectEl.innerHTML = '<option value="">Model list unavailable</option>';
    if (visionModelSelectEl) {
      visionModelSelectEl.innerHTML = '<option value="">Model list unavailable</option>';
      visionModelSelectEl.disabled = true;
      setVisionModel('');
    }
  }
}

async function applyModelSelection() {
  const selectedModel = modelSelectEl.value;
  if (!selectedModel) {
    return;
  }

  setIsModelSwitching(true);
  modelApplyBtn.disabled = true;
  modelSelectEl.disabled = true;
  sendBtn.disabled = true;
  promptEl.disabled = true;
  statusEl.textContent = 'Switching model...';
  statusEl.className = 'status connected';
  try {
    const res = await fetch(`${AIDER_API}/api/model/switch`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: selectedModel,
        timeout: 120
      })
    });

    const data = await res.json();
    if (!res.ok || data.success === false) {
      throw new Error(data.error || `HTTP ${res.status}`);
    }

    // Show detailed success message including verified loaded model
    const loadedModel = data.loaded_model || selectedModel;
    const prevModel = data.previous_model || 'unknown';
    addMessage('system', `Model switched: ${prevModel} â†’ ${loadedModel}\nAgent: ${data.agent_model}\nAider: ${data.aider_model}`);

    // Persist model selection to cookie
    setCookie(COOKIE_KEYS.MODEL, loadedModel);

    // Reset switching flag BEFORE checkHealth so status shows correctly
    setIsModelSwitching(false);
    await checkHealth();
  } catch (err) {
    addMessage('error', `Failed to set model: ${err.message}`);
    setIsModelSwitching(false);
    await checkHealth();
  } finally {
    // Ensure UI is re-enabled even if something went wrong
    modelApplyBtn.disabled = false;
    modelSelectEl.disabled = false;
    sendBtn.disabled = false;
    promptEl.disabled = false;
  }
}

async function runFullHealthCheck(allowHeal) {
  try {
    const res = await fetch(`${getMainApiBase()}/health/full`);
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    const data = await res.json();
    if (data.overall_status === 'ok') {
      return;
    }

    const autoHealTargets = [];
    if (data.aider_api?.status !== 'ok') {
      autoHealTargets.push('aider');
    }
    if (data.ollama?.status !== 'ok') {
      autoHealTargets.push('ollama');
    }

    if (allowHeal && autoHealTargets.length > 0) {
      statusEl.textContent = `Healing: ${autoHealTargets.join(', ')}`;
      statusEl.className = 'status error';
      await Promise.all(autoHealTargets.map(service => restartService(service)));
      await checkHealth();
    }
  } catch (err) {
    console.warn('Full health check failed:', err.message);
  }
}

async function restartService(service) {
  try {
    const res = await fetch(`${getMainApiBase()}/ops/restart/${service}`, { method: 'POST' });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    return await res.json();
  } catch (err) {
    console.warn(`Restart ${service} failed:`, err.message);
    return null;
  }
}

async function loadProjects() {
  console.log('loadProjects() called, fetching from', `${MAIN_API}/projects`);
  try {
    const res = await fetch(`${MAIN_API}/projects`);
    console.log('loadProjects response status:', res.status);
    const projectList = await res.json();
    setProjects(projectList);
    console.log('loadProjects got projects:', projectList);
    renderProjects();
    // Note: Auto-selection now handled by restoreSelectionsFromCookies() in init()
  } catch (err) {
    console.error('loadProjects error:', err);
    projectListEl.innerHTML = '<li style="color: #ff6b6b;">Failed to load</li>';
  }
}

function renderProjects() {
  if (state.projects.length === 0) {
    projectListEl.innerHTML = '<li style="color: #666;">No projects yet</li>';
    return;
  }
  projectListEl.innerHTML = state.projects.map(p => `
    <li class="${state.selectedProject?.id === p.id ? 'selected' : ''} has-tooltip"
        onclick="selectProject(${p.id})">
      <div class="project-row">
        <span class="project-title">${escapeHtml(p.name || 'Untitled project')}</span>
        <div class="project-actions">
          <button onclick="event.stopPropagation(); showEditProjectModal(${p.id})">Edit</button>
          <button class="delete" onclick="event.stopPropagation(); deleteProject(${p.id})">Delete</button>
        </div>
      </div>
      ${renderTooltip([
        { label: 'ID', value: p.id ?? '-' },
        { label: 'Workspace', value: p.workspace_path || '-' },
        { label: 'Environment', value: p.environment || '-' },
        { label: 'Created', value: formatDate(p.created_at) }
      ])}
    </li>
  `).join('');
}

async function selectProject(projectId) {
  console.log('selectProject called with:', projectId);
  const project = state.projects.find(p => p.id === projectId);
  if (!project) {
    return;
  }
  setSelectedProject(project);
  setSelectedTask(null);
  renderProjects();

  // Persist selection to cookie
  setCookie(COOKIE_KEYS.PROJECT_ID, projectId);

  // Switch aider workspace (non-blocking)
  const workspaceName = getWorkspaceName(project.workspace_path);
  fetch(`${AIDER_API}/api/config`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ workspace: workspaceName })
  }).then(() => {
    addMessage('system', `Switched to workspace: ${workspaceName}`);
    logAiderWorkspaceAccess();
  }).catch(err => {
    console.warn('Workspace switch failed:', err.message);
    addMessage('system', `Using workspace: ${workspaceName} (offline mode)`);
  });

  // Load tasks and file tree immediately (don't wait for workspace switch)
  console.log('Loading tasks and file tree for project:', projectId);
  try {
    await Promise.all([
      loadTasks(projectId),
      loadFileTree(projectId),
      loadGitBranches(projectId)
    ]);
  } catch (err) {
    console.error('Error loading project data:', err);
  }
}

async function loadTasks(projectId) {
  try {
    const res = await fetch(`${MAIN_API}/projects/${projectId}/tasks`);
    const taskList = await res.json();
    setTasks(taskList);
    renderTasks();
    populateParentTaskOptions();
  } catch (err) {
    taskListEl.innerHTML = '<li style="color: #ff6b6b;">Failed to load</li>';
  }
}

function renderTasks() {
  if (state.tasks.length === 0) {
    taskListEl.innerHTML = '<li style="color: #666;">No tasks yet</li>';
    return;
  }
  taskListEl.innerHTML = state.tasks.map(t => {
    const title = t.title || 'Untitled task';
    const stage = t.stage || 'dev';
    const status = t.status || 'backlog';
    const tooltipRows = [
      { label: 'ID', value: t.id ?? '-' },
      { label: 'Project', value: t.project_id ?? '-' },
      t.parent_id ? { label: 'Parent', value: `#${t.parent_id}` } : null,
      { label: 'Status', value: status },
      { label: 'Stage', value: stage },
      { label: 'Created', value: formatDate(t.created_at) }
    ];
    return `
    <li class="${state.selectedTask?.id === t.id ? 'selected' : ''} has-tooltip"
        onclick="openTaskEditor(${t.id})">
      <div class="task-row">
        <span class="task-title" title="${escapeHtml(title)}">${escapeHtml(title)}</span>
      </div>
      ${renderTooltip(tooltipRows)}
    </li>
  `;
  }).join('');
}

function selectTask(taskId) {
  const task = findTaskById(taskId);
  setSelectedTask(task);
  renderTasks();
  if (task) {
    addMessage('system', `Selected task: ${task.title}`);
  }
}

function openTaskEditor(taskId) {
  selectTask(taskId);
  showEditTaskModal(taskId);
}

function findTaskById(taskId, list = state.tasks) {
  for (const task of list) {
    if (task.id === taskId) {
      return task;
    }
    if (task.children && task.children.length > 0) {
      const child = findTaskById(taskId, task.children);
      if (child) {
        return child;
      }
    }
  }
  return null;
}

// File tree functions
const fileTreeContent = document.getElementById('file-tree-content');

async function loadFileTree(projectId) {
  console.log('loadFileTree called with projectId:', projectId);
  fileTreeContent.innerHTML = '<span style="color: #888;">Loading files...</span>';
  try {
    const url = `${MAIN_API}/projects/${projectId}/files`;
    console.log('Fetching file tree from:', url);
    const res = await fetch(url);
    console.log('File tree response status:', res.status);
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    const data = await res.json();
    console.log('File tree data:', data);
    state.currentWorkspacePath = data.workspace || 'unknown';
    state.fileTree = data.files || [];
    console.log('Workspace:', state.currentWorkspacePath, 'Files count:', state.fileTree.length);
    renderFileTree();
  } catch (err) {
    console.error('loadFileTree error:', err);
    fileTreeContent.innerHTML = '<span style="color: #ff6b6b;">Failed to load: ' + err.message + '</span>';
  }
}

function renderFileTree() {
  // Show workspace path header (use friendly name for [%root%])
  const displayPath = state.currentWorkspacePath.startsWith('[%root%]')
    ? state.currentWorkspacePath.replace('[%root%]', 'v2 (self)')
    : `/workspaces/${state.currentWorkspacePath}`;
  let html = `<div style="color: #888; font-size: 11px; margin-bottom: 8px;">ðŸ“‚ ${displayPath}</div>`;

  if (state.fileTree.length === 0) {
    fileTreeContent.innerHTML = html + '<span style="color: #666;">No files found</span>';
    return;
  }

  fileTreeContent.innerHTML = html + renderTreeNode(state.fileTree);
}

function renderTreeNode(nodes, level = 0) {
  return nodes.map(node => {
    const isDir = node.type === 'directory';
    const icon = isDir ? 'ðŸ“' : 'ðŸ“„';
    const hasChildren = isDir && node.children && node.children.length > 0;

    const doubleClick = node.type === 'file'
      ? `ondblclick="openFileInVSCode('${node.path}')"`
      : '';
    let html = `
      <div class="tree-item ${node.type}" onclick="handleFileClick('${node.path}', '${node.type}')" ${doubleClick}>
        ${hasChildren ? '<span class="tree-toggle" onclick="event.stopPropagation(); toggleTreeNode(this)">â–¶</span>' : '<span class="tree-toggle"></span>'}
        <span class="icon">${icon}</span>
        <span>${node.name}</span>
      </div>
    `;

    if (hasChildren) {
      html += `<div class="tree-children" style="display: none;">${renderTreeNode(node.children, level + 1)}</div>`;
    }

    return html;
  }).join('');
}

function toggleTreeNode(el) {
  const children = el.parentElement.nextElementSibling;
  if (children && children.classList.contains('tree-children')) {
    const isHidden = children.style.display === 'none';
    children.style.display = isHidden ? 'block' : 'none';
    el.textContent = isHidden ? 'â–¼' : 'â–¶';
  }
}

function handleFileClick(path, type) {
  if (type === 'file') {
    addFileReference(path);
  }
}

function addFileReference(path) {
  if (!path) {
    return;
  }
  if (state.referencedFiles.includes(path)) {
    return;
  }
  setReferencedFiles([...state.referencedFiles, path]);
  renderFileReferences();
}

function removeFileReference(path) {
  setReferencedFiles(state.referencedFiles.filter(item => item !== path));
  renderFileReferences();
}

function renderFileReferences() {
  let refsEl = document.getElementById('file-references');
  if (!refsEl) {
    refsEl = document.createElement('div');
    refsEl.id = 'file-references';
    refsEl.className = 'file-references';
    fileTreeEl.appendChild(refsEl);
  }

  if (state.referencedFiles.length === 0) {
    refsEl.innerHTML = '';
    return;
  }

  refsEl.innerHTML = `
    <div class="file-references-title">File References</div>
    <div class="file-references-list">
      ${state.referencedFiles.map(path => `
        <span class="file-ref-chip" title="${path}">
          ${path}
          <button class="file-ref-remove" onclick="removeFileReference('${path}')">Ã—</button>
        </span>
      `).join('')}
    </div>
  `;

  const tokens = state.referencedFiles.map(path => `@${path}`).join(' ');
  const text = promptEl.value.trim();
  const cleaned = text.replace(/(^|\s)@[^\\s]+/g, '').trim();
  promptEl.value = cleaned ? `${cleaned} ${tokens}` : tokens;
}

async function logAiderWorkspaceAccess() {
  try {
    const res = await fetch(`${AIDER_API}/api/config`);
    if (!res.ok) return;
    const data = await res.json();
    const root = data.config?.workspaces_dir || '';
    const current = data.config?.current_workspace || '';
    if (root && current) {
      let displayRoot = root;
      let displayCurrent = current;
      if (state.selectedProject?.workspace_path?.startsWith('[%root%]')) {
        displayRoot = '/mnt/c/dropbox/_coding/agentic/v2';
        const subPath = state.selectedProject.workspace_path.replace('[%root%]', '').replace(/^\//, '');
        displayCurrent = subPath ? subPath : '[%root%]';
      }
      addMessage('system', `Aider workspace root: ${displayRoot} (current: ${displayCurrent})`);
    }
  } catch (err) {
    console.warn('Failed to fetch aider config:', err.message);
  }
}

async function loadGitBranches(projectId) {
  if (!projectId) {
    return;
  }
  gitBranchSelectEl.disabled = true;
  gitBranchSelectEl.innerHTML = '<option value="">Loading...</option>';
  try {
    const res = await fetch(`${MAIN_API}/projects/${projectId}/git/status`);
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    const data = await res.json();
    const branches = data.branches || [];
    if (!branches.length) {
      gitBranchSelectEl.innerHTML = '<option value="">No repo</option>';
      gitRemoteSelectEl.innerHTML = '<option value="">No remotes</option>';
      gitRemoteSelectEl.disabled = true;
      gitRemoteListEl.textContent = 'No remotes';
      gitCurrentBranchEl.textContent = 'Current branch: -';
      gitUserConfigEl.textContent = 'User: -';
      return;
    }
    gitBranchSelectEl.innerHTML = branches.map(branch => (
      `<option value="${branch}">${branch}</option>`
    )).join('');
    if (data.current) {
      gitBranchSelectEl.value = data.current;
    }
    gitBranchSelectEl.disabled = false;

    const remotes = data.remotes || [];
    if (remotes.length) {
      gitRemoteSelectEl.innerHTML = remotes.map(remote => (
        `<option value="${remote.name}">${remote.name}</option>`
      )).join('');
      gitRemoteSelectEl.disabled = false;
      gitRemoteListEl.innerHTML = remotes.map(remote => (
        `<div>${remote.name} â†’ ${remote.url}</div>`
      )).join('');
    } else {
      gitRemoteSelectEl.innerHTML = '<option value="">No remotes</option>';
      gitRemoteSelectEl.disabled = true;
      gitRemoteListEl.textContent = 'No remotes';
    }

    gitCurrentBranchEl.textContent = `Current branch: ${data.current || '-'}`;
    const userName = data.user_name || 'unset';
    const userEmail = data.user_email || 'unset';
    gitUserConfigEl.textContent = `User: ${userName} <${userEmail}>`;
    gitUserNameEl.value = data.user_name || '';
    gitUserEmailEl.value = data.user_email || '';
  } catch (err) {
    gitBranchSelectEl.innerHTML = '<option value="">No repo</option>';
    gitRemoteSelectEl.innerHTML = '<option value="">No remotes</option>';
    gitRemoteSelectEl.disabled = true;
    gitRemoteListEl.textContent = 'No remotes';
    gitCurrentBranchEl.textContent = 'Current branch: -';
    gitUserConfigEl.textContent = 'User: -';
    gitUserNameEl.value = '';
    gitUserEmailEl.value = '';
    console.warn('Failed to load branches:', err.message);
  }
}

async function checkoutBranch() {
  if (!state.selectedProject) {
    alert('Select a project first');
    return;
  }
  const branch = gitBranchSelectEl.value;
  if (!branch) {
    return;
  }
  try {
    const res = await fetch(`${MAIN_API}/projects/${state.selectedProject.id}/git/checkout`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ branch })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    const data = await res.json();
    addMessage('system', `Checked out branch: ${data.current || branch}`);
    appendGitLog(data);
    await loadGitBranches(state.selectedProject.id);
  } catch (err) {
    alert('Failed to checkout branch: ' + err.message);
  }
}

async function createBranch() {
  if (!state.selectedProject) {
    alert('Select a project first');
    return;
  }
  const branch = gitBranchInputEl.value.trim();
  if (!branch) {
    return;
  }
  try {
    const res = await fetch(`${MAIN_API}/projects/${state.selectedProject.id}/git/checkout`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ branch, create: true })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    const data = await res.json();
    gitBranchInputEl.value = '';
    addMessage('system', `Created branch: ${data.current || branch}`);
    appendGitLog(data);
    await loadGitBranches(state.selectedProject.id);
  } catch (err) {
    alert('Failed to create branch: ' + err.message);
  }
}

async function pullBranch() {
  if (!state.selectedProject) {
    alert('Select a project first');
    return;
  }
  const remote = gitRemoteSelectEl.value;
  try {
    const res = await fetch(`${MAIN_API}/projects/${state.selectedProject.id}/git/pull`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ remote })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    const data = await res.json();
    addMessage('system', `Pulled from ${remote || 'origin'}`);
    appendGitLog(data);
  } catch (err) {
    alert('Failed to pull: ' + err.message);
  }
}

async function pushBranch() {
  if (!state.selectedProject) {
    alert('Select a project first');
    return;
  }
  const remote = gitRemoteSelectEl.value;
  try {
    const res = await fetch(`${MAIN_API}/projects/${state.selectedProject.id}/git/push`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ remote })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    const data = await res.json();
    addMessage('system', `Pushed to ${remote || 'origin'}`);
    appendGitLog(data);
  } catch (err) {
    alert('Failed to push: ' + err.message);
  }
}

async function addRemote() {
  if (!state.selectedProject) {
    alert('Select a project first');
    return;
  }
  const name = gitRemoteNameEl.value.trim();
  const url = gitRemoteUrlEl.value.trim();
  if (!name || !url) {
    alert('Remote name and URL required');
    return;
  }
  try {
    const res = await fetch(`${MAIN_API}/projects/${state.selectedProject.id}/git/remote`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, url })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    const data = await res.json();
    gitRemoteNameEl.value = '';
    gitRemoteUrlEl.value = '';
    addMessage('system', `Added remote: ${name}`);
    appendGitLog(data);
    await loadGitBranches(state.selectedProject.id);
  } catch (err) {
    alert('Failed to add remote: ' + err.message);
  }
}

function showGitModal() {
  if (!state.selectedProject) {
    alert('Select a project first');
    return;
  }
  document.getElementById('git-modal').style.display = 'flex';
  loadGitBranches(state.selectedProject.id);
}

function hideGitModal() {
  document.getElementById('git-modal').style.display = 'none';
}

function showSettingsModal() {
  document.getElementById('settings-modal').style.display = 'flex';
  loadSettings();
}

function hideSettingsModal() {
  document.getElementById('settings-modal').style.display = 'none';
}

function setupImageDropzone() {
  if (!imageDropzoneEl || !imageInputEl) {
    return;
  }
  imageDropzoneEl.addEventListener('dragover', (event) => {
    event.preventDefault();
    imageDropzoneEl.classList.add('dragover');
  });
  imageDropzoneEl.addEventListener('dragleave', () => {
    imageDropzoneEl.classList.remove('dragover');
  });
  imageDropzoneEl.addEventListener('drop', (event) => {
    event.preventDefault();
    imageDropzoneEl.classList.remove('dragover');
    const files = Array.from(event.dataTransfer.files || []);
    handleImageFiles(files);
  });
  imageInputEl.addEventListener('change', (event) => {
    const files = Array.from(event.target.files || []);
    handleImageFiles(files);
    imageInputEl.value = '';
  });
}

function openImagePicker() {
  if (imageInputEl) {
    imageInputEl.click();
  }
}

function handleImageFiles(files) {
  const images = files.filter(file => file.type.startsWith('image/'));
  images.forEach(file => {
    const reader = new FileReader();
    reader.onload = () => {
      setAttachedImages([
        ...state.attachedImages,
        {
          name: file.name,
          dataUrl: reader.result
        }
      ]);
      renderImageList();
    };
    reader.readAsDataURL(file);
  });
}

function renderImageList() {
  if (!imageListEl) return;
  if (state.attachedImages.length === 0) {
    imageListEl.innerHTML = '';
    return;
  }
  imageListEl.innerHTML = state.attachedImages.map((img, idx) => `
    <span class="image-chip">
      ${img.name}
      <button onclick="removeImage(${idx})">Ã—</button>
    </span>
  `).join('');
}

function removeImage(index) {
  setAttachedImages(state.attachedImages.filter((_, idx) => idx !== index));
  renderImageList();
}

function clearImages() {
  setAttachedImages([]);
  renderImageList();
}

async function describeImages(images) {
  const results = [];
  for (const img of images) {
    const base64 = await getResizedImageBase64(img.dataUrl || '', visionImageMaxSize);
    if (!base64) {
      results.push({
        name: img.name,
        location: img.name,
        description: null,
        error: 'invalid data'
      });
      continue;
    }
    try {
      const payload = {
        filename: img.name,
        data: base64,
        compact: true
      };
      if (state.visionModel) {
        payload.model = state.visionModel;
      }
      const res = await fetch(`${AIDER_API}/api/vision/describe`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data = await res.json();
      if (res.ok && data.success && data.description) {
        results.push({
          name: img.name,
          location: img.name,
          description: data.description,
          error: null
        });
      } else {
        results.push({
          name: img.name,
          location: img.name,
          description: null,
          error: data.error || 'vision model not configured'
        });
      }
    } catch (err) {
      results.push({
        name: img.name,
        location: img.name,
        description: null,
        error: err.message
      });
    }
  }
  return results;
}

async function initGitRepo() {
  if (!state.selectedProject) {
    alert('Select a project first');
    return;
  }
  try {
    const res = await fetch(`${MAIN_API}/projects/${state.selectedProject.id}/git/init`, {
      method: 'POST'
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    const data = await res.json();
    addMessage('system', 'Initialized git repo');
    appendGitLog(data);
    await loadGitBranches(state.selectedProject.id);
  } catch (err) {
    alert('Failed to init repo: ' + err.message);
  }
}

async function saveGitUser() {
  if (!state.selectedProject) {
    alert('Select a project first');
    return;
  }
  const name = gitUserNameEl.value.trim();
  const email = gitUserEmailEl.value.trim();
  if (!name || !email) {
    alert('User name and email required');
    return;
  }
  try {
    const res = await fetch(`${MAIN_API}/projects/${state.selectedProject.id}/git/config`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, email })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    const data = await res.json();
    addMessage('system', `Git user set: ${name} <${email}>`);
    appendGitLog(data);
    await loadGitBranches(state.selectedProject.id);
  } catch (err) {
    alert('Failed to save git user: ' + err.message);
  }
}

function appendGitLog(payload) {
  if (!gitLogEl || !payload) {
    return;
  }
  const stdout = (payload.stdout || '').trim();
  const stderr = (payload.stderr || '').trim();
  const lines = [];
  if (stdout) lines.push(stdout);
  if (stderr) lines.push(stderr);
  if (!lines.length) {
    lines.push('OK');
  }
  const stamp = new Date().toLocaleTimeString();
  const entry = `[${stamp}] ${lines.join('\\n')}`;
  gitLogEl.textContent = `${entry}\\n\\n${gitLogEl.textContent}`.trim();
}

async function loadSettings() {
  settingsListEl.textContent = 'Loading...';
  try {
    const res = await fetch(`${MAIN_API}/api/env`);
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    const data = await res.json();
    setEnvEntries(data.entries || []);
    renderSettings();
  } catch (err) {
    settingsListEl.textContent = `Failed to load settings: ${err.message}`;
  }
}

function renderSettings() {
  const filter = (settingsFilterEl.value || '').toLowerCase();
  const rows = state.envEntries.map((entry, idx) => {
    if (entry.type === 'pair') {
      if (filter && !entry.key.toLowerCase().includes(filter)) {
        return '';
      }
      return `
        <div class="settings-row">
          <label>${entry.key}</label>
          <input data-env-index="${idx}" value="${entry.value || ''}">
        </div>
      `;
    }
    if (entry.type === 'comment' && entry.value) {
      if (filter) return '';
      return `<div class="settings-comment">${entry.value}</div>`;
    }
    return '';
  }).join('');
  settingsListEl.innerHTML = rows || '<div class="settings-comment">No settings</div>';
}

async function applySettings() {
  const updates = {};
  settingsListEl.querySelectorAll('input[data-env-index]').forEach(input => {
    const index = Number(input.dataset.envIndex);
    const entry = state.envEntries[index];
    if (entry && entry.type === 'pair') {
      updates[entry.key] = input.value;
    }
  });

  const restartServices = [];
  if (restartMainEl.checked) restartServices.push('main');
  if (restartAiderEl.checked) restartServices.push('aider');
  if (restartOllamaEl.checked) restartServices.push('ollama');
  if (restartDbEl.checked) restartServices.push('db');

  try {
    const res = await fetch(`${MAIN_API}/api/env`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ updates, restart_services: restartServices })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    const data = await res.json();
    addMessage('system', `Settings updated: ${data.updated_keys?.length || 0} keys`);
    hideSettingsModal();
  } catch (err) {
    alert('Failed to apply settings: ' + err.message);
  }
}

if (settingsFilterEl) {
  settingsFilterEl.addEventListener('input', renderSettings);
}

function openFileInVSCode(path) {
  if (!state.selectedProject || !path) {
    return;
  }
  let workspacePath = state.selectedProject.workspace_path || '';
  let fullPath;

  // Handle [%root%] - project root directory
  if (workspacePath.startsWith('[%root%]')) {
    // For [%root%], the base is the project root itself
    const basePath = '/mnt/c/dropbox/_coding/agentic/v2';
    // Remove [%root%] prefix and any leading slash
    const subPath = workspacePath.replace('[%root%]', '').replace(/^\//, '');
    if (subPath) {
      fullPath = `${basePath}/${subPath}/${path}`.replace(/\/+/g, '/');
    } else {
      fullPath = `${basePath}/${path}`.replace(/\/+/g, '/');
    }
  } else {
    // Normalize workspace path - extract just the workspace name
    // "/workspaces/beatbridge_app" â†’ "beatbridge_app"
    // "./workspaces/poc/" â†’ "poc"
    // "poc" â†’ "poc"
    workspacePath = workspacePath.replace(/^\.?\/?(workspaces\/)?/, '').replace(/\/+$/, '');

    // Build full host path (WSL)
    const basePath = '/mnt/c/dropbox/_coding/agentic/v2/workspaces';
    fullPath = `${basePath}/${workspacePath}/${path}`.replace(/\/+/g, '/');
  }

  // Convert WSL path to Windows path for VS Code
  // /mnt/c/... â†’ C:/...
  if (fullPath.startsWith('/mnt/')) {
    const parts = fullPath.split('/');
    const drive = parts[2].toUpperCase();
    fullPath = `${drive}:/${parts.slice(3).join('/')}`;
  }

  window.location.href = `vscode://file/${fullPath}`;
}

// Modal functions
function showNewProjectModal() {
  document.getElementById('new-project-modal').style.display = 'flex';
}

function showNewTaskModal() {
  if (!state.selectedProject) {
    alert('Select a project first');
    return;
  }
  document.getElementById('new-task-status').value = 'backlog';
  document.getElementById('new-task-stage').value = 'dev';
  populateParentTaskOptions(pendingParentTaskId);
  pendingParentTaskId = null;
  document.getElementById('new-task-modal').style.display = 'flex';
}

function createSubtask(parentTaskId) {
  if (!parentTaskId) return;
  pendingParentTaskId = parentTaskId;
  showNewTaskModal();
}

function hideModals() {
  document.getElementById('new-project-modal').style.display = 'none';
  document.getElementById('edit-project-modal').style.display = 'none';
  document.getElementById('new-task-modal').style.display = 'none';
  document.getElementById('edit-task-modal').style.display = 'none';
  document.getElementById('git-modal').style.display = 'none';
  document.getElementById('settings-modal').style.display = 'none';
  setEditingProjectId(null);
  setEditingTaskId(null);
}

async function createProject() {
  const name = document.getElementById('new-project-name').value.trim();
  const workspace = document.getElementById('new-project-workspace').value.trim();

  console.log('createProject called', { name, workspace });

  if (!name || !workspace) {
    alert('Please fill in both project name and workspace path');
    return;
  }

  try {
    console.log('Sending POST to', `${MAIN_API}/projects`);
    const res = await fetch(`${MAIN_API}/projects`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, workspace_path: workspace, environment: 'local' })
    });

    console.log('Response status:', res.status);

    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }

    const project = await res.json();
    console.log('Created project:', project);

    setProjects([...state.projects, project]);
    renderProjects();
    hideModals();
    document.getElementById('new-project-name').value = '';
    document.getElementById('new-project-workspace').value = '';
  } catch (err) {
    console.error('createProject error:', err);
    alert('Failed to create project: ' + err.message);
  }
}

function showEditProjectModal(projectId) {
  const project = state.projects.find(p => p.id === projectId);
  if (!project) {
    alert('Project not found');
    return;
  }
  setEditingProjectId(projectId);
  document.getElementById('edit-project-name').value = project.name || '';
  document.getElementById('edit-project-workspace').value = getWorkspaceName(project.workspace_path);
  document.getElementById('edit-project-environment').value = project.environment || 'local';
  document.getElementById('edit-project-modal').style.display = 'flex';
}

async function updateProject() {
  if (!state.editingProjectId) {
    alert('Select a project first');
    return;
  }
  const name = document.getElementById('edit-project-name').value.trim();
  const workspace = document.getElementById('edit-project-workspace').value.trim();
  const environment = document.getElementById('edit-project-environment').value.trim();

  try {
    const res = await fetch(`${MAIN_API}/projects/${state.editingProjectId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, workspace_path: workspace, environment })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    const updated = await res.json();
    setProjects(state.projects.map(p => p.id === updated.id ? updated : p));
    if (state.selectedProject?.id === updated.id) {
      setSelectedProject(updated);
      await selectProject(updated.id);
    } else {
      renderProjects();
    }
    hideModals();
  } catch (err) {
    alert('Failed to update project: ' + err.message);
  }
}

async function deleteProject(projectId) {
  if (!confirm('Delete this project?')) {
    return;
  }
  try {
    const res = await fetch(`${MAIN_API}/projects/${projectId}`, { method: 'DELETE' });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    await res.json();
    setProjects(state.projects.filter(p => p.id !== projectId));
    if (state.selectedProject?.id === projectId) {
      setSelectedProject(null);
      setSelectedTask(null);
      setTasks([]);
      taskListEl.innerHTML = '<li style="color: #666;">Select a project</li>';
      document.getElementById('file-tree-content').innerHTML = '<span style="color: #666;">Select a project</span>';
      // Clear the project cookie since deleted project was selected
      deleteCookie(COOKIE_KEYS.PROJECT_ID);
    }
    renderProjects();
  } catch (err) {
    alert('Failed to delete project: ' + err.message);
  }
}

async function createTask() {
  const title = document.getElementById('new-task-title').value.trim();
  const description = document.getElementById('new-task-desc').value.trim();
  const parentRaw = newTaskParentSelectEl ? newTaskParentSelectEl.value : '';
  const status = document.getElementById('new-task-status').value;
  const stage = document.getElementById('new-task-stage').value;
  if (!title) return;

  let parentId = null;
  if (parentRaw) {
    parentId = parseInt(parentRaw, 10);
    if (Number.isNaN(parentId)) parentId = null;
  }

  try {
    const res = await fetch(`${MAIN_API}/tasks`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        project_id: state.selectedProject.id,
        parent_id: parentId,
        title,
        description,
        status,
        stage
      })
    });
    await res.json();
    await loadTasks(state.selectedProject.id);
    hideModals();
    document.getElementById('new-task-title').value = '';
    document.getElementById('new-task-desc').value = '';
    if (newTaskParentSelectEl) newTaskParentSelectEl.value = '';
  } catch (err) {
    alert('Failed to create task: ' + err.message);
  }
}

function showEditTaskModal(taskId) {
  const task = findTaskById(taskId);
  if (!task) {
    alert('Task not found');
    return;
  }
  setEditingTaskId(taskId);
  document.getElementById('edit-task-title').value = task.title || '';
  document.getElementById('edit-task-desc').value = task.description || '';
  document.getElementById('edit-task-status').value = task.status || 'backlog';
  document.getElementById('edit-task-stage').value = task.stage || 'dev';
  if (task.parent_id) {
    const parent = findTaskById(task.parent_id);
    if (editTaskParentRowEl && editTaskParentLinkEl) {
      editTaskParentRowEl.style.display = 'block';
      const label = parent
        ? `#${parent.id} ${parent.title || 'Untitled task'}`
        : `#${task.parent_id}`;
      editTaskParentLinkEl.textContent = label;
      editTaskParentLinkEl.onclick = (event) => {
        event.preventDefault();
        openTaskEditor(task.parent_id);
      };
    }
  } else if (editTaskParentRowEl) {
    editTaskParentRowEl.style.display = 'none';
    if (editTaskParentLinkEl) {
      editTaskParentLinkEl.textContent = '';
      editTaskParentLinkEl.onclick = null;
    }
  }
  document.getElementById('edit-task-modal').style.display = 'flex';
  resetCommentForm();
  loadTaskAcceptanceCriteria(taskId);
  loadTaskComments(taskId);
  loadTaskAttachments(taskId);
}

async function updateTask() {
  if (!state.editingTaskId || !state.selectedProject) {
    alert('Select a task first');
    return;
  }
  const title = document.getElementById('edit-task-title').value.trim();
  const description = document.getElementById('edit-task-desc').value.trim();
  const status = document.getElementById('edit-task-status').value;
  const stage = document.getElementById('edit-task-stage').value;

  try {
    const res = await fetch(`${MAIN_API}/tasks/${state.editingTaskId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title, description, status, stage })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    await res.json();
    await loadTasks(state.selectedProject.id);
    hideModals();
  } catch (err) {
    alert('Failed to update task: ' + err.message);
  }
}

async function deleteTask(taskId) {
  if (!state.selectedProject) {
    alert('Select a project first');
    return;
  }
  if (!confirm('Delete this task?')) {
    return;
  }
  try {
    const res = await fetch(`${MAIN_API}/tasks/${taskId}`, { method: 'DELETE' });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    await res.json();
    if (state.selectedTask?.id === taskId) {
      setSelectedTask(null);
    }
    await loadTasks(state.selectedProject.id);
    hideModals();
  } catch (err) {
    alert('Failed to delete task: ' + err.message);
  }
}

async function loadTaskAcceptanceCriteria(taskId) {
  if (!criteriaListEl) return;
  criteriaListEl.textContent = 'Loading...';
  try {
    const res = await fetch(`${MAIN_API}/tasks/${taskId}/acceptance`);
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(errorText || `HTTP ${res.status}`);
    }
    taskCriteria = await res.json();
    renderAcceptanceCriteria();
  } catch (err) {
    criteriaListEl.textContent = `Failed to load criteria: ${err.message}`;
  }
}

function renderAcceptanceCriteria() {
  if (!criteriaListEl) return;
  if (!taskCriteria.length) {
    criteriaListEl.textContent = 'No criteria';
    return;
  }
  criteriaListEl.innerHTML = taskCriteria.map(criteria => `
    <div class="criteria-item">
      <label class="criteria-main">
        <input type="checkbox" ${criteria.passed ? 'checked' : ''} onchange="toggleAcceptanceCriteria(${criteria.id}, this.checked)">
        <span class="criteria-desc">${escapeHtml(criteria.description)}</span>
      </label>
      <div class="criteria-meta">By ${escapeHtml(criteria.author)} | ${formatDate(criteria.updated_at)}</div>
      <div class="criteria-actions">
        <button class="delete" onclick="deleteAcceptanceCriteria(${criteria.id})">Delete</button>
      </div>
    </div>
  `).join('');
}

async function addAcceptanceCriteria() {
  if (!state.selectedTask) {
    alert('Select a task first');
    return;
  }
  const description = criteriaDescEl?.value.trim() || '';
  const author = criteriaAuthorEl?.value.trim() || '';
  if (!description) {
    alert('Criteria description is required');
    return;
  }
  try {
    const res = await fetch(`${MAIN_API}/tasks/${state.selectedTask.id}/acceptance`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        description,
        author: author || null
      })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(errorText || `HTTP ${res.status}`);
    }
    await res.json();
    if (criteriaDescEl) criteriaDescEl.value = '';
    if (criteriaAuthorEl) criteriaAuthorEl.value = '';
    await loadTaskAcceptanceCriteria(state.selectedTask.id);
  } catch (err) {
    alert('Failed to add criteria: ' + err.message);
  }
}

async function toggleAcceptanceCriteria(criteriaId, passed) {
  if (!state.selectedTask) return;
  try {
    const res = await fetch(`${MAIN_API}/tasks/${state.selectedTask.id}/acceptance/${criteriaId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ passed })
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(errorText || `HTTP ${res.status}`);
    }
    await res.json();
    await loadTaskAcceptanceCriteria(state.selectedTask.id);
  } catch (err) {
    alert(`Failed to update criteria: ${err.message}`);
  }
}

async function deleteAcceptanceCriteria(criteriaId) {
  if (!state.selectedTask) return;
  if (!confirm('Delete this criteria?')) return;
  try {
    const res = await fetch(`${MAIN_API}/tasks/${state.selectedTask.id}/acceptance/${criteriaId}`, {
      method: 'DELETE'
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(errorText || `HTTP ${res.status}`);
    }
    await res.json();
    await loadTaskAcceptanceCriteria(state.selectedTask.id);
  } catch (err) {
    alert(`Failed to delete criteria: ${err.message}`);
  }
}

async function loadTaskComments(taskId) {
  if (!taskCommentsListEl) return;
  taskCommentsListEl.textContent = 'Loading...';
  try {
    const res = await fetch(`${MAIN_API}/tasks/${taskId}/comments`);
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    taskComments = await res.json();
    renderTaskComments();
    updateAttachmentCommentOptions();
  } catch (err) {
    taskCommentsListEl.textContent = `Failed to load comments: ${err.message}`;
  }
}

function renderTaskComments() {
  if (!taskCommentsListEl) return;
  if (!taskComments.length) {
    taskCommentsListEl.textContent = 'No comments';
    return;
  }
  taskCommentsListEl.innerHTML = taskComments.map(comment => `
    <div class="comment-item">
      <div class="comment-meta">
        <div>ID: ${escapeHtml(comment.id)} | Task: ${escapeHtml(comment.task_id)}</div>
        <div>Author: ${escapeHtml(comment.author || 'human')}</div>
        <div>Created: ${escapeHtml(formatDate(comment.created_at))} | Updated: ${escapeHtml(formatDate(comment.updated_at))}</div>
      </div>
      <div>${escapeHtml(comment.body || '')}</div>
      <div class="comment-actions">
        <button onclick="startEditComment(${comment.id})">Edit</button>
        <button class="delete" onclick="deleteTaskComment(${comment.id})">Delete</button>
      </div>
    </div>
  `).join('');
}

function updateAttachmentCommentOptions() {
  if (!attachmentCommentIdEl) return;
  const current = attachmentCommentIdEl.value;
  const options = ['<option value="">Attach to task</option>'];
  taskComments.forEach(comment => {
    const preview = escapeHtml((comment.body || '').slice(0, 40));
    options.push(`<option value="${comment.id}">Comment #${comment.id} - ${preview}</option>`);
  });
  attachmentCommentIdEl.innerHTML = options.join('');
  if (current && [...attachmentCommentIdEl.options].some(opt => opt.value === current)) {
    attachmentCommentIdEl.value = current;
  }
}

function startEditComment(commentId) {
  const comment = taskComments.find(item => item.id === commentId);
  if (!comment) return;
  editingCommentId = commentId;
  if (commentIdEl) commentIdEl.value = String(commentId);
  if (commentAuthorEl) commentAuthorEl.value = comment.author || '';
  if (commentBodyEl) commentBodyEl.value = comment.body || '';
}

function resetCommentForm() {
  editingCommentId = null;
  if (commentIdEl) commentIdEl.value = '';
  if (commentAuthorEl) commentAuthorEl.value = '';
  if (commentBodyEl) commentBodyEl.value = '';
}

async function saveTaskComment() {
  if (!state.selectedTask) {
    alert('Select a task first');
    return;
  }
  const author = (commentAuthorEl?.value || '').trim();
  const body = (commentBodyEl?.value || '').trim();
  if (!body) {
    alert('Comment body is required');
    return;
  }
  const payload = { body };
  if (author) payload.author = author;

  const taskId = state.selectedTask.id;
  const url = editingCommentId
    ? `${MAIN_API}/tasks/${taskId}/comments/${editingCommentId}`
    : `${MAIN_API}/tasks/${taskId}/comments`;
  const method = editingCommentId ? 'PATCH' : 'POST';

  try {
    const res = await fetch(url, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    await res.json();
    resetCommentForm();
    await loadTaskComments(taskId);
  } catch (err) {
    alert(`Failed to save comment: ${err.message}`);
  }
}

async function deleteTaskComment(commentId) {
  if (!state.selectedTask) return;
  if (!confirm('Delete this comment?')) return;
  try {
    const res = await fetch(`${MAIN_API}/tasks/${state.selectedTask.id}/comments/${commentId}`, {
      method: 'DELETE'
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    await res.json();
    if (editingCommentId === commentId) resetCommentForm();
    await loadTaskComments(state.selectedTask.id);
  } catch (err) {
    alert(`Failed to delete comment: ${err.message}`);
  }
}

async function loadTaskAttachments(taskId) {
  if (!taskAttachmentsListEl) return;
  taskAttachmentsListEl.textContent = 'Loading...';
  try {
    const res = await fetch(`${MAIN_API}/tasks/${taskId}/attachments`);
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    taskAttachments = await res.json();
    renderTaskAttachments();
  } catch (err) {
    taskAttachmentsListEl.textContent = `Failed to load attachments: ${err.message}`;
  }
}

function renderTaskAttachments() {
  if (!taskAttachmentsListEl) return;
  if (!taskAttachments.length) {
    taskAttachmentsListEl.textContent = 'No attachments';
    return;
  }
  taskAttachmentsListEl.innerHTML = taskAttachments.map(attachment => `
    <div class="attachment-item">
      <div class="attachment-row">
        <a class="attachment-link" href="${MAIN_API}${attachment.url}" target="_blank">${escapeHtml(attachment.filename)}</a>
        <div class="attachment-meta">ID: ${escapeHtml(attachment.id)} | Task: ${escapeHtml(attachment.task_id)} | Comment: ${escapeHtml(attachment.comment_id ?? '-')}</div>
        <div class="attachment-meta">Type: ${escapeHtml(attachment.mime_type)} | Size: ${escapeHtml(attachment.size_bytes)} bytes</div>
        <div class="attachment-meta">Storage: ${escapeHtml(attachment.storage_path)}</div>
        <div class="attachment-meta">URL: ${escapeHtml(attachment.url)}</div>
        <div class="attachment-meta">Uploaded by: ${escapeHtml(attachment.uploaded_by)} | Created: ${escapeHtml(formatDate(attachment.created_at))}</div>
      </div>
      <div class="attachment-actions">
        <button class="delete" onclick="deleteTaskAttachment(${attachment.id})">Delete</button>
      </div>
    </div>
  `).join('');
}

async function uploadTaskAttachment() {
  if (!state.selectedTask) {
    alert('Select a task first');
    return;
  }
  const file = attachmentFileEl?.files?.[0];
  if (!file) {
    alert('Select a file to upload');
    return;
  }
  const formData = new FormData();
  formData.append('file', file);
  if (attachmentUploadedByEl?.value) {
    formData.append('uploaded_by', attachmentUploadedByEl.value.trim());
  }
  if (attachmentCommentIdEl?.value) {
    formData.append('comment_id', attachmentCommentIdEl.value);
  }
  try {
    const res = await fetch(`${MAIN_API}/tasks/${state.selectedTask.id}/attachments`, {
      method: 'POST',
      body: formData
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    await res.json();
    if (attachmentFileEl) attachmentFileEl.value = '';
    if (attachmentUploadedByEl) attachmentUploadedByEl.value = '';
    if (attachmentCommentIdEl) attachmentCommentIdEl.value = '';
    await loadTaskAttachments(state.selectedTask.id);
  } catch (err) {
    alert(`Failed to upload attachment: ${err.message}`);
  }
}

async function deleteTaskAttachment(attachmentId) {
  if (!state.selectedTask) return;
  if (!confirm('Delete this attachment?')) return;
  try {
    const res = await fetch(`${MAIN_API}/tasks/${state.selectedTask.id}/attachments/${attachmentId}`, {
      method: 'DELETE'
    });
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    await res.json();
    await loadTaskAttachments(state.selectedTask.id);
  } catch (err) {
    alert(`Failed to delete attachment: ${err.message}`);
  }
}

async function switchAgentModel(model, label) {
  const res = await fetch(`${AIDER_API}/api/model/switch`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model, timeout: 120 })
  });
  const data = await res.json();
  if (!res.ok || data.success === false) {
    throw new Error(data.error || `HTTP ${res.status}`);
  }
  addMessage('system', `${label} model loaded: ${data.loaded_model || model}`);
  return data;
}

function buildImageContextLayer(descriptions) {
  const context = {};
  descriptions.forEach((entry, index) => {
    const key = entry.name || `image_${index + 1}`;
    const description = entry.description
      ? entry.description
      : `Description unavailable (${entry.error || 'unknown'})`;
    context[key] = {
      location: entry.location || entry.name || key,
      description
    };
  });
  return `IMAGE_CONTEXT:\n${JSON.stringify(context, null, 2)}`;
}

async function fetchTaskContext(taskId) {
  try {
    const res = await fetch(`${MAIN_API}/tasks/${taskId}/context`);
    if (!res.ok) {
      return null;
    }
    return await res.json();
  } catch (err) {
    console.warn('Failed to load task context:', err.message);
    return null;
  }
}

function buildTaskContextLayer(context) {
  if (!context) return '';
  return `TASK_CONTEXT:\n${JSON.stringify(context, null, 2)}`;
}

async function postAgentComment(taskId, stage) {
  const context = await fetchTaskContext(taskId);
  if (!context) return;
  const gitInfo = context.git || {};
  const summary = gitInfo.last_commit_summary;
  const files = Array.isArray(gitInfo.last_commit_files) ? gitInfo.last_commit_files : [];
  const working = Array.isArray(gitInfo.working_changes) ? gitInfo.working_changes : [];

  const lines = [`Agent run (${stage})`];
  if (summary) lines.push(`Last commit: ${summary}`);
  if (files.length) lines.push(`Last commit files: ${files.join(', ')}`);
  if (working.length) {
    const workingList = working.map(item => `${item.status} ${item.path}`).join(', ');
    lines.push(`Working changes: ${workingList}`);
  }
  const body = lines.join('\n');

  try {
    const res = await fetch(`${MAIN_API}/tasks/${taskId}/comments`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        author: `agent.${stage}`,
        body
      })
    });
    if (!res.ok) {
      return;
    }
    if (state.selectedTask?.id === taskId) {
      await loadTaskComments(taskId);
    }
  } catch (err) {
    console.warn('Failed to post agent comment:', err.message);
  }
}

// Chat functions
async function sendMessage() {
  if (state.isModelSwitching) {
    addMessage('system', 'Model is switching. Please wait...');
    return;
  }
  const text = promptEl.value.trim();
  if (!text) return;

  addMessage('user', text);
  promptEl.value = '';
  sendBtn.disabled = true;
  statusEl.textContent = 'Agent is working...';

  const workspace = state.selectedProject
    ? getWorkspaceName(state.selectedProject.workspace_path)
    : 'poc';

  try {
    const promptSections = [];
    if (state.selectedTask) {
      const taskContext = await fetchTaskContext(state.selectedTask.id);
      const taskLayer = buildTaskContextLayer(taskContext);
      if (taskLayer) {
        promptSections.push(taskLayer);
      }
    }

    if (state.attachedImages.length > 0) {
      const activeModel = modelSelectEl.value || '';
      const visionModel = state.visionModel || '';
      let switched = false;
      if (visionModel && activeModel && visionModel !== activeModel) {
        statusEl.textContent = `Loading vision model: ${visionModel}...`;
        statusEl.className = 'status connected';
        try {
          await switchAgentModel(visionModel, 'Vision');
          switched = true;
        } catch (err) {
          addMessage('error', `Vision model switch failed: ${err.message}`);
        }
      }

      const imageDescriptions = await describeImages(state.attachedImages);
      if (imageDescriptions.length > 0) {
        const imageLayer = buildImageContextLayer(imageDescriptions);
        promptSections.push(imageLayer);
      }

      if (switched && activeModel) {
        statusEl.textContent = `Restoring model: ${activeModel}...`;
        statusEl.className = 'status connected';
        try {
          await switchAgentModel(activeModel, 'Primary');
        } catch (err) {
          addMessage('error', `Failed to restore model: ${err.message}`);
        }
      }
    }

    promptSections.push(`REQUEST:\n${text}`);
    const fullPrompt = promptSections.join('\n\n');

    const res = await fetch(`${AIDER_API}/api/agent/run`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        task: fullPrompt,
        workspace,
        project_id: state.selectedProject?.id,
        task_id: state.selectedTask?.id
      })
    });

    const data = await res.json();
    console.log('Agent response:', data);

    if (data.success || data.status === 'PASS') {
      const responseText = data.summary || 'Task completed';
      addMessage('assistant', responseText, data.tool_calls);
      statusEl.textContent = 'Ready';
      statusEl.className = 'status connected';
      // Refresh file tree after agent completes
      if (state.selectedProject) loadFileTree(state.selectedProject.id);
      if (state.selectedTask) {
        const stage = state.selectedTask.stage || 'dev';
        await postAgentComment(state.selectedTask.id, stage);
      }
    } else {
      addMessage('error', `Error: ${data.error || data.summary || 'Unknown error'}`);
      statusEl.textContent = 'Error - see output';
      statusEl.className = 'status error';
    }
  } catch (err) {
    console.error('Fetch error:', err);
    addMessage('error', 'Connection error: ' + err.message);
    statusEl.textContent = 'Connection failed';
    statusEl.className = 'status error';
  }

  sendBtn.disabled = false;
  clearImages();
}

// ============================================================================
// Log Streaming via WebSocket
// ============================================================================

const logsContentEl = document.getElementById('logs-content');
const logPanes = {
  ollama: document.getElementById('log-pane-ollama'),
  ollama_http: document.getElementById('log-pane-ollama_http'),
  aider: document.getElementById('log-pane-aider'),
  main: document.getElementById('log-pane-main')
};
const logsConnectionEl = document.getElementById('logs-connection');
const reconnectTimers = {};
const reconnectAttempts = {};
const MAX_RECONNECT_ATTEMPTS = 5;
const logPollingTimers = {};
const logLoadedOnce = {};
const LOG_POLL_INTERVAL_MS = 30000;

function toggleLogs() {
  state.logsCollapsed = !state.logsCollapsed;
  logsContentEl.classList.toggle('collapsed', state.logsCollapsed);
}

function switchLogTab(tab) {
  // Update tab UI
  document.querySelectorAll('.logs-tabs button').forEach(btn => {
    btn.classList.remove('active');
  });
  document.getElementById(`tab-${tab}`).classList.add('active');

  Object.keys(logPanes).forEach(key => {
    logPanes[key].style.display = key === tab ? 'block' : 'none';
  });

  setCurrentLogTab(tab);
  updateLogConnectionStatus(tab);

  if (!logLoadedOnce[tab]) {
    logPanes[tab].innerHTML = '<div class="log-line info">Loading recent logs for ' + tab + '...</div>';
    loadRecentLogs(tab, true);
  }

  if (!state.logSockets[tab] || state.logSockets[tab].readyState > 1) {
    connectLogStream(tab);
  }
}

function connectLogStream(container) {
  if (state.logSockets[container] && state.logSockets[container].readyState <= 1) {
    return;
  }
  const baseUrl = new URL(getMainApiBase());
  const wsProtocol = baseUrl.protocol === 'https:' ? 'wss:' : 'ws:';
  const wsUrl = `${wsProtocol}//${baseUrl.host}/ws/logs/${container}`;
  console.log('Connecting to WebSocket:', wsUrl);

  state.logSocketConnected[container] = false;
  updateLogConnectionStatus(container, 'connecting');

  try {
    state.logSockets[container] = new WebSocket(wsUrl);

    state.logSockets[container].onopen = () => {
      console.log('WebSocket connected:', container);
      reconnectAttempts[container] = 0;
      state.logSocketConnected[container] = true;
      updateLogConnectionStatus(container, 'connected');
    };

    state.logSockets[container].onmessage = (event) => {
      appendLogLine(event.data, '', container);
    };

    state.logSockets[container].onclose = (event) => {
      console.log('WebSocket closed:', container, event.code, event.reason);
      state.logSocketConnected[container] = false;
      updateLogConnectionStatus(container, 'disconnected');
      startLogPolling(container);

      // Auto-reconnect if not intentionally closed
      if ((reconnectAttempts[container] || 0) < MAX_RECONNECT_ATTEMPTS) {
        reconnectAttempts[container] = (reconnectAttempts[container] || 0) + 1;
        const delay = Math.min(1000 * reconnectAttempts[container], 5000);
        appendLogLine(
          `Connection lost. Reconnecting in ${delay/1000}s... (attempt ${reconnectAttempts[container]}/${MAX_RECONNECT_ATTEMPTS})`,
          'warn',
          container
        );
        reconnectTimers[container] = setTimeout(() => connectLogStream(container), delay);
      }
    };

    state.logSockets[container].onerror = (error) => {
      console.error('WebSocket error:', error);
      appendLogLine('WebSocket connection error - check if main-api can access Docker socket', 'error', container);
      state.logSocketConnected[container] = false;
      updateLogConnectionStatus(container, 'disconnected');
      startLogPolling(container);
    };
  } catch (err) {
    console.error('Failed to create WebSocket:', err);
    appendLogLine(`Failed to connect: ${err.message}`, 'error', container);
    state.logSocketConnected[container] = false;
    updateLogConnectionStatus(container, 'disconnected');
    startLogPolling(container);
  }
}

async function loadRecentLogs(container, replace = false) {
  try {
    const res = await fetch(`${MAIN_API}/logs/${container}?lines=200`);
    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }
    const data = await res.json();
    const lines = (data.logs || '').split('\n').filter(Boolean);
    if (replace) {
      logPanes[container].innerHTML = '';
    }
    if (lines.length === 0) {
      appendLogLine('No recent logs available.', 'info', container);
    } else if (replace) {
      lines.forEach(line => appendLogLine(line, '', container));
    }
    logLoadedOnce[container] = true;
  } catch (err) {
    logPanes[container].innerHTML = '';
    appendLogLine(`Failed to load logs: ${err.message}`, 'error', container);
  }
}

function startLogPolling(container) {
  if (state.logSocketConnected[container]) {
    return;
  }
  if (logPollingTimers[container]) {
    return;
  }
  loadRecentLogs(container, true);
  logPollingTimers[container] = setInterval(
    () => loadRecentLogs(container, true),
    LOG_POLL_INTERVAL_MS
  );
}

function stopLogPolling(container) {
  const timer = logPollingTimers[container];
  if (timer) {
    clearInterval(timer);
    logPollingTimers[container] = null;
  }
}

function appendLogLine(text, type = '', container = state.currentLogTab) {
  const line = document.createElement('div');
  line.className = 'log-line';

  // Auto-detect log level
  if (!type) {
    if (text.includes('ERROR') || text.includes('error') || text.includes('Error')) {
      type = 'error';
    } else if (text.includes('WARN') || text.includes('warn') || text.includes('Warning')) {
      type = 'warn';
    } else if (text.includes('INFO') || text.includes('===')) {
      type = 'info';
    }
  }

  if (type) {
    line.classList.add(type);
  }

  line.textContent = text;
  const pane = logPanes[container] || logsContentEl;
  pane.appendChild(line);

  // Auto-scroll to bottom
  logsContentEl.scrollTop = logsContentEl.scrollHeight;

  // Keep only last 500 lines
  while (pane.children.length > 500) {
    pane.removeChild(pane.firstChild);
  }
}

function updateLogConnectionStatus(container, forcedState = null) {
  if (container !== state.currentLogTab) {
    return;
  }
  const isConnected = forcedState === 'connected' || state.logSocketConnected[container];
  const isConnecting = forcedState === 'connecting';
  if (isConnecting) {
    logsConnectionEl.textContent = `${container} connecting...`;
    logsConnectionEl.className = 'connection-status connecting';
  } else if (isConnected) {
    logsConnectionEl.textContent = `${container} connected`;
    logsConnectionEl.className = 'connection-status connected';
  } else {
    logsConnectionEl.textContent = 'disconnected';
    logsConnectionEl.className = 'connection-status disconnected';
  }
}

function addMessage(type, content, toolCalls = null) {
  const div = document.createElement('div');
  div.className = 'message ' + type;

  if (type === 'assistant') {
    div.innerHTML = renderMarkdown(content);
    // Append tool calls if provided
    if (toolCalls && toolCalls.length > 0) {
      div.innerHTML += renderToolCalls(toolCalls);
    }
  } else {
    div.textContent = content;
  }

  messagesEl.appendChild(div);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

Object.assign(window, {
  showNewProjectModal,
  showNewTaskModal,
  showGitModal,
  showSettingsModal,
  hideModals,
  hideGitModal,
  hideSettingsModal,
  createProject,
  updateProject,
  deleteProject,
  createTask,
  createSubtask,
  updateTask,
  deleteTask,
  addAcceptanceCriteria,
  toggleAcceptanceCriteria,
  deleteAcceptanceCriteria,
  saveTaskComment,
  resetCommentForm,
  startEditComment,
  deleteTaskComment,
  uploadTaskAttachment,
  deleteTaskAttachment,
  selectProject,
  showEditProjectModal,
  openTaskEditor,
  openImagePicker,
  removeImage,
  handleFileClick,
  toggleTreeNode,
  removeFileReference,
  openFileInVSCode,
  runFullHealthCheck,
  applyModelSelection,
  toggleLogs,
  switchLogTab,
  initGitRepo,
  saveGitUser,
  checkoutBranch,
  createBranch,
  pullBranch,
  pushBranch,
  addRemote,
  applySettings,
  getEditingTaskId
});

if (visionModelSelectEl) {
  visionModelSelectEl.addEventListener('change', () => {
    const selected = visionModelSelectEl.value;
    setVisionModel(selected);
    if (selected) {
      setCookie(COOKIE_KEYS.VISION_MODEL, selected);
    } else {
      deleteCookie(COOKIE_KEYS.VISION_MODEL);
    }
  });
}

sendBtn.addEventListener('click', sendMessage);
promptEl.addEventListener('keypress', e => {
  if (e.key === 'Enter') sendMessage();
});

// Close modals on escape
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') hideModals();
});

// Initialize on load
init();
</script>
</body>
</html>
